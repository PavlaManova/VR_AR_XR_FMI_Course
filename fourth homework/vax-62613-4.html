<!DOCTYPE html>

<html>
	<head>
		<title>Michelin</title>
		<meta charset="utf-8">

		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

		<script src="three.min.js"></script>
		<script src="vax.js"></script>
	</head>

	<body>
		<script>
			vaxInit();

			// skeleton
	     {
         var pelvis = new THREE.Bone();

			// кости на единия крак
			var legA1 = new THREE.Bone(),
				legB1 = new THREE.Bone(),
				legC1 = new THREE.Bone(),
				legD1 = new THREE.Bone(); // фиктивна кост

			// кости на другия крак
			var legA2 = new THREE.Bone(),
				legB2 = new THREE.Bone(),
				legC2 = new THREE.Bone(),
				legD2 = new THREE.Bone(); // фиктивна кост

				var backA = new THREE.Bone(),
				backB = new THREE.Bone(),
				backC = new THREE.Bone(),
				backD = new THREE.Bone(); // фиктивна кост

			// кости на врата и главата
			var neck = new THREE.Bone(),
				head = new THREE.Bone();

			//кости на едната ръка
			var armA1 = new THREE.Bone();
			var armB1 = new THREE.Bone();
			var armC1 = new THREE.Bone();
			var armD1 = new THREE.Bone();

			//кости на другата ръка
			var armA2 = new THREE.Bone();
			var armB2 = new THREE.Bone();
			var armC2 = new THREE.Bone();
			var armD2 = new THREE.Bone();

			skeleton = new THREE.Skeleton( [pelvis,legA1,legB1,legC1,legD1,legA2,legB2,legC2,legD2] );

			// свързаност на костите
			pelvis.add( legA1, legA2 );

			legA1.add( legB1 );
			legB1.add( legC1 );
			legC1.add( legD1 );

			legA2.add( legB2 );
			legB2.add( legC2 );
			legC2.add( legD2 );

			pelvis.add(backA);
			backA.add(backB);
			backB.add(backC);
			backC.add(backD);

			backD.add(neck);
			neck.add(head);

			neck.add(armA1, armA2);
			armA1.add(armB1);
			armB1.add(armC1);
			armC1.add(armD1);

			armA2.add(armB2);
			armB2.add(armC2);
			armC2.add(armD2);

			// позиция на костите
			pelvis.position.y = 20;

			legA1.position.y = -2;
			legA1.position.z = 3;
			legB1.position.y = 20;
			legC1.position.y = 15;
			legD1.position.y = 5;

			legA2.position.y = -2;
			legA2.position.z = -3;
			legB2.position.y = 20;
			legC2.position.y = 15;
			legD2.position.y = 5;

			legA1.rotation.z = THREE.Math.degToRad( 180 );
			legA2.rotation.z = THREE.Math.degToRad( 180 );

			backA.position.y = 5;
			backB.position.y = 5;
			backC.position.y = 5;
			backD.position.y = 5;

			backA.rotation.z = 0.2;
			backB.rotation.z = -0.1;
			backC.rotation.z = -0.2;
			backD.rotation.z =0.2;

			neck.position.y = 2;
			head.position.y = 4;

			//neck.rotation.z = -0.3;

			armA1.position.y = -1;
			armA1.position.z = 7;
			armB1.position.y = -12;
			armC1.position.y = -9;
			armD1.position.y = -5;

			armA2.position.y = -1;
			armA2.position.z = -7;
			armB2.position.y = -12;
			armC2.position.y = -9;
			armD2.position.y = -5;
}

      var upperMuscleRight = createUpperThighMuscle(12,9);
      var upperMuscleLeft = createUpperThighMuscle(12,-9);

      var middleMuscleRight = createMiddleThighMuscle(6,10);
      var middleMuscleLeft = createMiddleThighMuscle(6,-10);

      var lowerMuscleRight = createLowerThighMuscle(0,7);
      var lowerMuscleLeft = createLowerThighMuscle(0,-7);

      var lowerMuscleRight2 = createLowerThighMuscle(-4,7);
      var lowerMuscleLeft2 = createLowerThighMuscle(-4,-7);

			function createUpperThighMuscle(translationY, translationZ)
      {
        var muscleGeometry = new THREE.SphereGeometry( 6, 40, 40 ).translate(0,translationY,translationZ);
				skinIndices = [],
				skinWeights = [];

        muscleGeometry.scale(0.8,1.1,0.7);

			// изчисляване на индексите и теглата на костите за всяка контролна точка
			var pos = muscleGeometry.getAttribute( 'position' );
			for( var i = 0; i<pos.count; i++ )
			{
          if(translationY>=0)
          {
            skinIndices.push( translationZ>0 ? 1 : 5, 0, 0, 0 );
  					skinWeights.push( 1, 0, 0, 0 );
          }
          else {
            skinIndices.push( translationZ>0 ? 2 : 6, 0, 0, 0 );
  					skinWeights.push( 1, 0, 0, 0 );
          }
			}

			// записване на индексите и теглата като атрибути на геометрията
			muscleGeometry.setAttribute( 'skinIndex', new THREE.Uint16BufferAttribute( skinIndices, 4 ) );
			muscleGeometry.setAttribute( 'skinWeight', new THREE.Float32BufferAttribute( skinWeights, 4 ) );

      var elongateGeometry = new THREE.SphereGeometry( 6, 40, 40 ).translate(0,translationY+7,translationZ);
      elongateGeometry.scale(0.6,0.7,0.7);

      var ballPositions = [],
        pos = elongateGeometry.getAttribute( 'position' );

      for( var i=0; i<pos.count; i++ )
      {
        ballPositions.push( pos.getX(i), pos.getY(i), pos.getZ(i) );
      }

      // записване на върховете на сфера като морфинг атрибут на позицията
      muscleGeometry.morphAttributes.position = [
				new THREE.Float32BufferAttribute( ballPositions, 3 )
			]

			var upperMuscle = new THREE.SkinnedMesh(
				muscleGeometry,
				new THREE.MeshPhongMaterial({color:'crimson',skinning: true})
			);
			upperMuscle.add( skeleton.bones[0] );
			upperMuscle.bind( skeleton );
			upperMuscle.normalizeSkinWeights( );
			scene.add( upperMuscle );
      return upperMuscle;
    }

      function createMiddleThighMuscle(translationY,translationZ)
      {
        var muscleGeometry = new THREE.SphereGeometry( 5, 40, 40 ).translate(0,translationY,translationZ);
        skinIndices = [],
        skinWeights = [];

        muscleGeometry.scale(0.7,0.7,0.6);

        // изчисляване на индексите и теглата на костите за всяка контролна точка
        var pos = muscleGeometry.getAttribute( 'position' );
        for( var i = 0; i<pos.count; i++ )
        {
          if(translationY>=0)
          {
            skinIndices.push( translationZ>0 ? 1 : 5, 0, 0, 0 );
  					skinWeights.push( 1, 0, 0, 0 );
          }
          else {
            skinIndices.push( translationZ>0 ? 2 : 6, 0, 0, 0 );
  					skinWeights.push( 1, 0, 0, 0 );
          }
        }

        // записване на индексите и теглата като атрибути на геометрията
        muscleGeometry.setAttribute( 'skinIndex', new THREE.Uint16BufferAttribute( skinIndices, 4 ) );
        muscleGeometry.setAttribute( 'skinWeight', new THREE.Float32BufferAttribute( skinWeights, 4 ) );

        var elongateGeometry = new THREE.SphereGeometry( 5, 40, 40 ).translate(0,translationY+2,translationZ);
        elongateGeometry.scale(0.7,0.9,0.7);

        var ballPositions = [],
        pos = elongateGeometry.getAttribute( 'position' );

        for( var i=0; i<pos.count; i++ )
        {
          ballPositions.push( pos.getX(i), pos.getY(i), pos.getZ(i) );
        }

        // записване на върховете на сфера като морфинг атрибут на позицията
        muscleGeometry.morphAttributes.position = [
        new THREE.Float32BufferAttribute( ballPositions, 3 )
        ]

        var middleMuscle = new THREE.SkinnedMesh(
        muscleGeometry,
        new THREE.MeshPhongMaterial({color:'crimson',skinning: true})
        );
        middleMuscle.add( skeleton.bones[0] );
        middleMuscle.bind( skeleton );
        middleMuscle.normalizeSkinWeights( );
        scene.add( middleMuscle );
        return middleMuscle;
      }

      function createLowerThighMuscle(translationY,translationZ)
      {
        var muscleGeometry = new THREE.SphereGeometry( 4, 40, 40 ).translate(0,translationY,translationZ);
				skinIndices = [],
				skinWeights = [];

        muscleGeometry.scale(0.7,1,0.7);

			// изчисляване на индексите и теглата на костите за всяка контролна точка
			var pos = muscleGeometry.getAttribute( 'position' );
			for( var i = 0; i<pos.count; i++ )
			{
        if(translationY>=0)
        {
          skinIndices.push( translationZ>0 ? 1 : 5, 0, 0, 0 );
          skinWeights.push( 1, 0, 0, 0 );
        }
        else {
          skinIndices.push( translationZ>0 ? 2 : 6, 0, 0, 0 );
          skinWeights.push( 1, 0, 0, 0 );
        }
			}

			// записване на индексите и теглата като атрибути на геометрията
			muscleGeometry.setAttribute( 'skinIndex', new THREE.Uint16BufferAttribute( skinIndices, 4 ) );
			muscleGeometry.setAttribute( 'skinWeight', new THREE.Float32BufferAttribute( skinWeights, 4 ) );

      var elongateGeometry = new THREE.SphereGeometry( 4, 40, 40 ).translate(0,translationY,translationZ);
      if(translationY<0)
      elongateGeometry.scale(0.7,1,0.7);
      else
      elongateGeometry.scale(0.9,1,0.9);

      var ballPositions = [],
        pos = elongateGeometry.getAttribute( 'position' );

      for( var i=0; i<pos.count; i++ )
      {
        ballPositions.push( pos.getX(i), pos.getY(i), pos.getZ(i) );
      }

      // записване на върховете на сфера като морфинг атрибут на позицията
      muscleGeometry.morphAttributes.position = [
				new THREE.Float32BufferAttribute( ballPositions, 3 )
			]

			var lowerMuscle = new THREE.SkinnedMesh(
				muscleGeometry,
				new THREE.MeshPhongMaterial({color:'crimson',skinning: true})
			);
			lowerMuscle.add( skeleton.bones[0] );
			lowerMuscle.bind( skeleton );
			lowerMuscle.normalizeSkinWeights( );
			scene.add( lowerMuscle );
      return lowerMuscle;
      }

      var helper = new THREE.SkeletonHelper( pelvis );
				scene.add( helper, pelvis );

        var fatGeometry = new THREE.SphereGeometry( 12, 40, 40 ).translate(0,26,0);

        fatGeometry.scale(1,0.8,1);

        var pos = fatGeometry.getAttribute( 'position' );
        skinIndices = [],
				skinWeights = [];

        var c = 0.9;
        var d = 1.3;
        var f = 0.8;
        var ballPositions = [];
        for(var i=0; i<pos.count; i++)
        {
          skinIndices.push( 17, 0, 0, 0 );
          skinWeights.push( 1, 0, 0, 0 );
          if(pos.getY(i)>1)
            {
              if(pos.getX(i)>0)
              {
                if(pos.getZ(i)>0)
                ballPositions.push(pos.getX(i)+d,pos.getY(i)-0.5,pos.getZ(i)-d);
                else {
                    ballPositions.push(pos.getX(i)+d,pos.getY(i)-0.5,pos.getZ(i)+d);
                }
              }

             else {
               if(pos.getZ(i)>0)
               ballPositions.push(pos.getX(i)-d,pos.getY(i)-0.5,pos.getZ(i)+d);
               else {
                   ballPositions.push(pos.getX(i)-d,pos.getY(i)-0.5,pos.getZ(i)-d);
               }
             }
            }
            else if(pos.getY(i)>0)
              {
                if(pos.getX(i)>0)
                {
                  if(pos.getZ(i)>0)
                  ballPositions.push(pos.getX(i)+f,pos.getY(i)-0.5,pos.getZ(i)-f);
                  else {
                      ballPositions.push(pos.getX(i)+f,pos.getY(i)-0.5,pos.getZ(i)+f);
                  }
                }

               else {
                 if(pos.getZ(i)>0)
                 ballPositions.push(pos.getX(i)-f,pos.getY(i)-0.5,pos.getZ(i)+f);
                 else {
                     ballPositions.push(pos.getX(i)-f,pos.getY(i)-0.5,pos.getZ(i)-f);
                 }
               }
              }
              else {
                ballPositions.push(pos.getX(i)>0 ? pos.getX(i)-0.1 : pos.getX(i)+0.1,
                                   pos.getY(i)-0.5,
                                   pos.getZ(i)>0 ? pos.getZ(i)-0.1 : pos.getZ(i)+0.1);
              }
        }
        // записване на върховете на сфера като морфинг атрибут на позицията
        fatGeometry.morphAttributes.position = [
        new THREE.Float32BufferAttribute( ballPositions, 3 )
      ]
      fatGeometry.rotateY(Math.PI/2);
        var body = new THREE.SkinnedMesh(
        fatGeometry,
        new THREE.MeshPhongMaterial({color:'crimson',skinning: true})
        );
        body.add( skeleton.bones[0] );
			body.bind( skeleton );
		//	body.normalizeSkinWeights( );
        scene.add( body );


        var dependabilityBody = 0;
			function animate( t )
			{
				var s = Math.sin(4*t);
				var z = -s;

				legA1.rotation.z = THREE.Math.degToRad( 180 - 45*s );
				legB1.rotation.z = THREE.Math.degToRad( -60 - 60*s );
				legC1.rotation.z = THREE.Math.degToRad( 90 );

				legA2.rotation.z = THREE.Math.degToRad( 180 - 45*z );
				legB2.rotation.z = THREE.Math.degToRad( -60 - 60*z );

				armA1.rotation.z = THREE.Math.degToRad( 45*s );
        armB1.rotation.z = THREE.Math.degToRad( 40+40*s );

				armA2.rotation.z = THREE.Math.degToRad( 45*z );
        armB2.rotation.z = THREE.Math.degToRad( 40 + 40*z );

				//mesh.rotation.y = t/2;

        upperMuscleRight.morphTargetInfluences[ 0 ] = THREE.Math.clamp( -s, 0, 1 );
        upperMuscleLeft.morphTargetInfluences[ 0 ] = THREE.Math.clamp( s, 0, 1 );

        middleMuscleRight.morphTargetInfluences[ 0 ] = THREE.Math.clamp( -s, 0, 1 );
        middleMuscleLeft.morphTargetInfluences[ 0 ] = THREE.Math.clamp( s, 0, 1 );

        lowerMuscleRight.morphTargetInfluences[ 0 ] = THREE.Math.clamp( -s, 0, 1 );
        lowerMuscleLeft.morphTargetInfluences[ 0 ] = THREE.Math.clamp( s, 0, 1 );

        lowerMuscleRight2.morphTargetInfluences[ 0 ] = THREE.Math.clamp( s, 0, 1 );
        lowerMuscleLeft2.morphTargetInfluences[ 0 ] = THREE.Math.clamp( -s, 0, 1 );

        if(dependabilityBody<1)
        {
          dependabilityBody+=0.003;
          body.morphTargetInfluences[0]=dependabilityBody
        }

				//helper.visible = (t%6) < 3;
        pelvis.rotation.y=t/2;
			}


		</script>
	</body>
</html>
